#
# French JavaScript messages file.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Codegen
msg.dup.parms =\
    \uC778\uC790 "{0}"\uAC00 \uC911\uBCF5\uB418\uC5C8\uC2B5\uB2C8\uB2E4.

msg.too.big.jump =\
    \uBCF5\uC7A1\uD55C \uD504\uB85C\uADF8\uB7A8: \uAC70\uB300\uD55C \uC810\uD504 \uC624\uD504\uC14B

msg.too.big.index =\
    \uBCF5\uC7A1\uD55C \uD504\uB85C\uADF8\uB7A8: \uB0B4\uBD80 \uC778\uB371\uC2A4\uAC00 64K \uD55C\uACC4\uB97C \uB118\uC5C8\uC2B5\uB2C8\uB2E4.

msg.while.compiling.fn =\
    \uD568\uC218\uB97C \uCEF4\uD30C\uC77C\uD558\uB358 \uB3C4\uC911\uC5D0 \uCF54\uB4DC \uC0DD\uC131 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD558\uC600\uC2B5\uB2C8\uB2E4. "{0}": {1}

msg.while.compiling.script =\
    \uC2A4\uD06C\uB9BD\uD2B8\uB97C \uCEF4\uD30C\uC77C\uD558\uB358 \uB3C4\uC911\uC5D0 \uCF54\uB4DC \uC0DD\uC131 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD558\uC600\uC2B5\uB2C8\uB2E4. {0}

# Context
msg.ctor.not.found =\
    "{0}" \uC758 \uC0DD\uC131\uC790\uAC00 \uC874\uC7AC\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.

msg.not.ctor =\
    "{0}" \uB294 \uC0DD\uC131\uC790\uAC00 \uC544\uB2D9\uB2C8\uB2E4.

# FunctionObject
msg.varargs.ctor =\
    Method or constructor "{0}" must be static with the signature \
    "(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)" \
    to define a variable arguments constructor.

msg.varargs.fun =\
    Method "{0}" must be static with the signature \
    "(Context cx, Scriptable thisObj, Object[] args, Function funObj)" \
    to define a variable arguments function.

msg.incompat.call =\
    \uBA54\uC11C\uB4DC "{0}" \uAC00 \uD638\uD658\uB418\uC9C0 \uC54A\uB294 \uC624\uBE0C\uC81D\uD2B8\uC5D0\uC11C \uD638\uCD9C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.

msg.bad.parms =\
    Unsupported parameter type "{0}" in method "{1}".

msg.bad.method.return =\
    Unsupported return type "{0}" in method "{1}".

msg.bad.ctor.return =\
    Construction of objects of type "{0}" is not supported.

msg.no.overload =\
    Method "{0}" occurs multiple times in class "{1}".

msg.method.not.found =\
    \uBA54\uC11C\uB4DC "{0}" \uAC00 "{1}" \uC5D0\uC11C \uBC1C\uACAC\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.

# IRFactory

msg.bad.for.in.lhs =\
    for..in \uB8E8\uD504\uC758 \uC88C\uCE21\uC774 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.

msg.mult.index =\
    for..in \uB8E8\uD504\uC5D0\uB294 \uD55C\uAC00\uC9C0 \uBCC0\uC218\uB9CC \uD5C8\uC6A9\uB429\uB2C8\uB2E4.

msg.bad.for.in.destruct =\
	for..in \uB8E8\uD504\uC758 \uC88C\uCE21\uC740 \uD0A4/\uAC12 \uC30D \uD615\uD0DC\uC758 \uAE38\uC774 2\uC758 \uBC30\uC5F4\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4.\
    
msg.cant.convert =\
    \uD0C0\uC785 "{0}" \uB85C \uBCC0\uD658\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.bad.assign.left =\
    \uC62C\uBC14\uB974\uC9C0 \uC54A\uC740 \uC88C\uCE21\uC5D0 \uD560\uB2F9\uC774 \uC77C\uC5B4\uB0AC\uC2B5\uB2C8\uB2E4.

msg.bad.decr =\
    \uC62C\uBC14\uB974\uC9C0 \uC54A\uC740 \uAC10\uC18C \uC5F0\uC0B0\uC790\uC785\uB2C8\uB2E4.

msg.bad.incr =\
    \uC62C\uBC14\uB974\uC9C0 \uC54A\uC740 \uC99D\uAC00 \uC5F0\uC0B0\uC790\uC785\uB2C8\uB2E4.

msg.bad.yield =\
    Yield\uB294 \uD568\uC218 \uC548\uC5D0 \uC788\uC5B4\uC57C \uD569\uB2C8\uB2E4.

msg.yield.parenthesized =\
    Yield \uD45C\uD604\uC740 \uAD04\uD638 \uC548\uC5D0 \uC788\uC5B4\uC57C \uD569\uB2C8\uB2E4.

# NativeGlobal
msg.cant.call.indirect =\
    \uD568\uC218 "{0}" must be called directly, and not by way of a \
    function of another name.

msg.eval.nonstring =\
    Calling eval() with anything other than a primitive string value will \
    simply return the value. Is this what you intended?

msg.eval.nonstring.strict =\
    Calling eval() with anything other than a primitive string value is not \
    allowed in strict mode.

msg.bad.destruct.op =\
    Invalid destructuring assignment operator

# NativeCall
msg.only.from.new =\
    "{0}" may only be invoked from a "new" expression.

msg.deprec.ctor =\
    The "{0}" constructor is deprecated.

# NativeFunction
msg.no.function.ref.found =\
    no source found to decompile function reference {0}

msg.arg.isnt.array =\
    second argument to Function.prototype.apply must be an array

# NativeGlobal
msg.bad.esc.mask =\
    invalid string escape mask

# NativeJavaClass
msg.cant.instantiate =\
    error instantiating ({0}): class {1} is interface or abstract

msg.bad.ctor.sig =\
    Found constructor with wrong signature: \
    {0} calling {1} with signature {2}

msg.not.java.obj =\
    Expected argument to getClass() to be a Java object.

msg.no.java.ctor =\
    Java constructor for "{0}" with arguments "{1}" not found.

# NativeJavaMethod
msg.method.ambiguous =\
    The choice of Java method {0}.{1} matching JavaScript argument types ({2}) is ambiguous; \
    candidate methods are: {3}

msg.constructor.ambiguous =\
    The choice of Java constructor {0} matching JavaScript argument types ({1}) is ambiguous; \
    candidate constructors are: {2}

# NativeJavaObject
msg.conversion.not.allowed =\
    Cannot convert {0} to {1}

msg.no.empty.interface.conversion =\
    Cannot convert function to interface {0} with no methods

msg.no.function.interface.conversion =\
    Cannot convert function to interface {0} since it contains methods with \
    different names

msg.undefined.function.interface =\
    Property "{0}" is not defined in interface adapter

msg.not.function.interface =\
    Property "{0}" is not a function in interface adapter

# NativeJavaPackage
msg.not.classloader =\
    Constructor for "Packages" expects argument of type java.lang.Classloader

# NativeRegExp
msg.bad.quant =\
    Invalid quantifier {0}

msg.overlarge.backref =\
    Overly large back reference {0}

msg.overlarge.min =\
    Overly large minimum {0}

msg.overlarge.max =\
    Overly large maximum {0}

msg.zero.quant =\
    Zero quantifier {0}

msg.max.lt.min =\
    Maximum {0} less than minimum

msg.unterm.quant =\
    Unterminated quantifier {0}

msg.unterm.paren =\
    Unterminated parenthetical {0}

msg.unterm.class =\
    Unterminated character class {0}

msg.bad.range =\
    Invalid range in character class.

msg.trail.backslash =\
    Trailing \\ in regular expression.

msg.re.unmatched.right.paren =\
    unmatched ) in regular expression.

msg.no.regexp =\
    Regular expressions are not available.

msg.bad.backref =\
    back-reference exceeds number of capturing parentheses.

msg.bad.regexp.compile =\
    Only one argument may be specified if the first argument to \
    RegExp.prototype.compile is a RegExp object.

msg.arg.not.object =\
    Expected argument of type object, but instead had type {0}

# NativeDate
msg.invalid.date =\
    \uC62C\uBC14\uB974\uC9C0 \uC54A\uC740 \uB0A0\uC9DC\uC785\uB2C8\uB2E4.

msg.toisostring.must.return.primitive =\
    toISOString must return a primitive value, but instead returned "{0}"

# Parser
msg.got.syntax.errors = \
    Compilation produced {0} syntax errors.

msg.var.redecl =\
    \uD0C0\uC785\uC624\uB958: \uBCC0\uC218 {0}\uB97C \uC911\uBCF5\uC120\uC5B8\uD558\uC600\uC2B5\uB2C8\uB2E4.

msg.const.redecl =\
    \uD0C0\uC785\uC624\uB958: \uC0C1\uC218 {0}\uB97C \uC911\uBCF5\uC120\uC5B8\uD558\uC600\uC2B5\uB2C8\uB2E4.
    
msg.let.redecl =\
    \uD0C0\uC785\uC624\uB958: \uBCC0\uC218(let) {0}\uB97C \uC911\uBCF5\uC120\uC5B8\uD558\uC600\uC2B5\uB2C8\uB2E4.

msg.parm.redecl =\
	\uD0C0\uC785\uC624\uB958: \uAC00\uB9E4\uAC1C\uBCC0\uC218 {0}\uB97C \uC911\uBCF5\uC120\uC5B8\uD558\uC600\uC2B5\uB2C8\uB2E4.

msg.fn.redecl =\
    \uD0C0\uC785\uC624\uB958: \uD568\uC218 {0}\uB97C \uC911\uBCF5\uC120\uC5B8\uD558\uC600\uC2B5\uB2C8\uB2E4.

msg.let.decl.not.in.block =\
    SyntaxError: let declaration not directly within block

msg.bad.object.init =\
    SyntaxError: invalid object initializer

# NodeTransformer
msg.dup.label =\
    \uB808\uC774\uBE14\uC744 \uC911\uBCF5\uC120\uC5B8\uD558\uC600\uC2B5\uB2C8\uB2E4.

msg.undef.label =\
    \uC120\uC5B8\uB418\uC9C0 \uC54A\uC740 \uB808\uC774\uBE14 \uC785\uB2C8\uB2E4.

msg.bad.break =\
    unlabelled break must be inside loop or switch

msg.continue.outside =\
    continue\uB294 \uBC18\uB4DC\uC2DC \uBC18\uBCF5\uBB38 \uC548\uC5D0 \uC788\uC5B4\uC57C \uD569\uB2C8\uB2E4.

msg.continue.nonloop =\
    continue can only use labeles of iteration statements

msg.bad.throw.eol =\
    Line terminator is not allowed between the throw keyword and throw \
    expression.

msg.no.paren.parms =\
    missing ( before function parameters.

msg.no.parm =\
    \uAC00\uB9E4\uAC1C\uBCC0\uC218\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.paren.after.parms =\
	\uAC00\uB9E4\uAC1C\uBCC0\uC218 \uB4A4\uC5D0 ')' \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.brace.body =\
    \uD568\uC218 \uC55E\uCCB4 \uB4A4\uC5D0 '{' \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.brace.after.body =\
    \uD568\uC218 \uB4A4\uCCB4 \uC55E\uC5D0 '}' \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.paren.cond =\
    \uC870\uAC74 \uC55E\uC5D0 '(' \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.paren.after.cond =\
    \uC870\uAC74 \uB4A4\uC5D0 ')' \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.semi.stmt =\
    \uBB38\uC7A5 \uB4A4\uC5D0 ';' \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.missing.semi =\
    \uBB38\uC7A5 \uC804\uC5D0 ';' \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.name.after.dot =\
    . \uC5F0\uC0B0\uC790 \uB4A4\uC5D0 \uC774\uB984\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.name.after.coloncolon =\
    :: \uC5F0\uC0B0\uC790 \uB4A4\uC5D0 \uC774\uB984\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.name.after.dotdot =\
    .. \uC5F0\uC0B0\uC790 \uB4A4\uC5D0 \uC774\uB984\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.name.after.xmlAttr =\
    missing name after .@

msg.no.bracket.index =\
    missing ] in index expression

msg.no.paren.switch =\
    missing ( before switch expression

msg.no.paren.after.switch =\
    missing ) after switch expression

msg.no.brace.switch =\
    missing '{' before switch body

msg.bad.switch =\
    \uC624\uB78D\uB974\uC9C0 \uC54A\uC740 switch \uBB38\uC785\uB2C8\uB2E4.

msg.no.colon.case =\
    case \uB4A4\uC5D0 ":" \uC774 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.double.switch.default =\
    switch\uBB38\uC5D0 default \uB808\uC774\uBE14\uC774 \uC911\uBCF5\uB418\uC5C8\uC2B5\uB2C8\uB2E4.

msg.no.while.do =\
    do-while \uB8E8\uD504\uC5D0 while\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.paren.for =\
    for \uB4A4\uC5D0 ( \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.semi.for =\
    for \uB8E8\uD504 \uCD08\uAE30\uD654\uBB38 \uB4A4\uC5D0 ; \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.semi.for.cond =\
    for \uB8E8\uD504 \uC870\uAC74\uBB38 \uB4A4\uC5D0 ; \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.
    
msg.in.after.for.name =\
    for \uC548\uC5D0 in \uC774 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.paren.for.ctrl =\
    missing ) after for-loop control

msg.no.paren.with =\
    missing ( before with-statement object

msg.no.paren.after.with =\
    missing ) after with-statement object
    
msg.no.with.strict =\
    scrict \uBAA8\uB4DC\uC5D0\uC11C\uB294 with \uBB38\uC744 \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.paren.after.let =\
    let \uB4A4\uC5D0 ( \uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.no.paren.let =\
    missing ) after variable list

msg.no.curly.let =\
    missing } after let statement

msg.bad.return =\
    \uC62C\uBC14\uB974\uC9C0 \uC54A\uC740 \uBC18\uD658\uBB38\uC785\uB2C8\uB2E4.

msg.no.brace.block =\
    missing } in compound statement

msg.bad.label =\
    \uC62C\uBC14\uB974\uC9C0 \uC54A\uC740 \uB808\uC774\uBE14\uC774\uB2E4.

msg.bad.var =\
    \uBCC0\uC218 \uC774\uB984\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.bad.var.init =\
    \uC62C\uBC14\uB974\uC9C0 \uC54A\uC740 \uBCC0\uC218 \uCD08\uAE30\uD654\uC785\uB2C8\uB2E4.

msg.no.colon.cond =\
    missing : in conditional expression

msg.no.paren.arg =\
    missing ) after argument list

msg.no.bracket.arg =\
    missing ] after element list

msg.bad.prop =\
    invalid property id

msg.no.colon.prop =\
    missing : after property id

msg.no.brace.prop =\
    missing } after property list

msg.no.paren =\
    missing ) in parenthetical

msg.reserved.id =\
    identifier is a reserved word

msg.no.paren.catch =\
    missing ( before catch-block condition

msg.bad.catchcond =\
    invalid catch block condition

msg.catch.unreachable =\
    any catch clauses following an unqualified catch are unreachable

msg.no.brace.try =\
    missing '{' before try block

msg.no.brace.catchblock =\
    missing '{' before catch-block body

msg.try.no.catchfinally =\
    ''try'' \uBB38\uC5D0 ''catch'' or ''finally''

msg.no.return.value =\
	function {0} does not always return a value

msg.anon.no.return.value =\
	anonymous function does not always return a value

msg.return.inconsistent =\
	return statement is inconsistent with previous usage

msg.generator.returns =\
	TypeError: generator function {0} returns a value

msg.anon.generator.returns =\
	TypeError: anonymous generator function returns a value

msg.syntax =\
    \uBB38\uBC95 \uC624\uB958

msg.unexpected.eof =\
    \uC608\uC0C1\uD558\uC9C0 \uBABB\uD55C \uD30C\uC77C\uC758 \uB05D

msg.XML.bad.form =\
    illegally formed XML syntax

msg.XML.not.available =\
    XML runtime not available

msg.too.deep.parser.recursion =\
    Too deep recursion while parsing

msg.too.many.constructor.args =\
    Too many constructor arguments

msg.too.many.function.args =\
    Too many function arguments

msg.no.side.effects =\
    Code has no side effects

msg.extra.trailing.semi =\
    Extraneous trailing semicolon

msg.extra.trailing.comma =\
    Trailing comma is not legal in an ECMA-262 object initializer

msg.trailing.array.comma =\
    Trailing comma in array literal has different cross-browser behavior

msg.equal.as.assign =\
    Test for equality (==) mistyped as assignment (=)?

msg.var.hides.arg =\
    Variable {0} hides argument

msg.destruct.assign.no.init =\
    Missing = in destructuring declaration

msg.no.octal.strict =\
    Octal numbers prohibited in strict mode.

msg.dup.obj.lit.prop.strict =\
    Property "{0}" already defined in this object literal.

msg.dup.param.strict =\
    Parameter "{0}" already declared in this function.

msg.bad.id.strict =\
    "{0}" is not a valid identifier for this use in strict mode.

# ScriptRuntime

# is there a better message for this? 
# it's currently only used as a poison pill for caller, caller and arguments properties
msg.op.not.allowed =\
    This operation is not allowed.

msg.no.properties =\
    {0} has no properties.

msg.invalid.iterator =\
    Invalid iterator value

msg.iterator.primitive =\
    __iterator__ returned a primitive value

msg.assn.create.strict =\
    Assignment to undeclared variable {0}

msg.ref.undefined.prop =\
    Reference to undefined property "{0}"

msg.prop.not.found =\
    Property {0} not found.

msg.set.prop.no.setter =\
    Cannot set property {0} that has only a getter.

msg.invalid.type =\
    Invalid JavaScript value of type {0}

msg.primitive.expected =\
    Primitive type expected (had {0} instead)

msg.namespace.expected =\
    Namespace object expected to left of :: (found {0} instead)

msg.null.to.object =\
    Cannot convert null to an object.

msg.undef.to.object =\
    Cannot convert undefined to an object.

msg.cyclic.value =\
    Cyclic {0} value not allowed.

msg.is.not.defined =\
    "{0}" \uAC00 \uC815\uC758\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.

msg.undef.prop.read =\
    Cannot read property "{1}" from {0}

msg.undef.prop.write =\
    Cannot set property "{1}" of {0} to "{2}"

msg.undef.prop.delete =\
    Cannot delete property "{1}" of {0}

msg.undef.method.call =\
    Cannot call method "{1}" of {0}

msg.undef.with =\
    Cannot apply "with" to {0}

msg.isnt.function =\
    {0} is not a function, it is {1}.

msg.isnt.function.in =\
    Cannot call property {0} in object {1}. It is not a function, it is "{2}".

msg.function.not.found =\
    Cannot find function {0}.

msg.function.not.found.in =\
    Cannot find function {0} in object {1}.

msg.isnt.xml.object =\
    {0} is not an xml object.

msg.no.ref.to.get =\
    {0} is not a reference to read reference value.

msg.no.ref.to.set =\
    {0} is not a reference to set reference value to {1}.

msg.no.ref.from.function =\
    Function {0} can not be used as the left-hand side of assignment \
    or as an operand of ++ or -- operator.

msg.bad.default.value =\
    Object''s getDefaultValue() method returned an object.

msg.instanceof.not.object = \
    Can''t use ''instanceof'' on a non-object.

msg.instanceof.bad.prototype = \
    ''prototype'' property of {0} is not an object.

msg.in.not.object = \
    Can''t use ''in'' on a non-object.

msg.bad.radix = \
    illegal radix {0}.

# ScriptableObject
msg.default.value =\
    Cannot find default value for object.

msg.zero.arg.ctor =\
    Cannot load class "{0}" which has no zero-parameter constructor.

duplicate.defineClass.name =\
    Invalid method "{0}": name "{1}" is already in use.

msg.ctor.multiple.parms =\
    Can''t define constructor or class {0} since more than one \
    constructor has multiple parameters.

msg.extend.scriptable =\
    {0} must extend ScriptableObject in order to define property {1}.

msg.bad.getter.parms =\
    In order to define a property, getter {0} must have zero parameters \
    or a single ScriptableObject parameter.

msg.obj.getter.parms =\
    Expected static or delegated getter {0} to take a ScriptableObject parameter.

msg.getter.static =\
    Getter and setter must both be static or neither be static.

msg.setter.return =\
    Setter must have void return type: {0}

msg.setter2.parms =\
    Two-parameter setter must take a ScriptableObject as its first parameter.

msg.setter1.parms =\
    Expected single parameter setter for {0}

msg.setter2.expected =\
    Expected static or delegated setter {0} to take two parameters.

msg.setter.parms =\
    Expected either one or two parameters for setter.

msg.setter.bad.type =\
    Unsupported parameter type "{0}" in setter "{1}".

msg.add.sealed =\
    Cannot add a property to a sealed object: {0}.

msg.remove.sealed =\
    Cannot remove a property from a sealed object: {0}.

msg.modify.sealed =\
    Cannot modify a property of a sealed object: {0}.

msg.modify.readonly =\
    Cannot modify readonly property: {0}.

msg.both.data.and.accessor.desc =\
    Cannot be both a data and an accessor descriptor.

msg.change.configurable.false.to.true =\
    Cannot change the configurable attribute of "{0}" from false to true.

msg.change.enumerable.with.configurable.false =\
    Cannot change the enumerable attribute of "{0}" because configurable is false.

msg.change.writable.false.to.true.with.configurable.false =\
    Cannot change the writable attribute of "{0}" from false to true because configurable is false.

msg.change.value.with.writable.false =\
    Cannot change the value of attribute "{0}" because writable is false.

msg.change.getter.with.configurable.false =\
    Cannot change the get attribute of "{0}" because configurable is false.

msg.change.setter.with.configurable.false =\
    Cannot change the set attribute of "{0}" because configurable is false.

msg.change.property.data.to.accessor.with.configurable.false =\
    Cannot change "{0}" from a data property to an accessor property because configurable is false.

msg.change.property.accessor.to.data.with.configurable.false =\
    Cannot change "{0}" from an accessor property to a data property because configurable is false.

msg.not.extensible =\
    Cannot add properties to this object because extensible is false.

# TokenStream
msg.missing.exponent =\
    missing exponent

msg.caught.nfe =\
    number format error

msg.unterminated.string.lit =\
    unterminated string literal

msg.unterminated.comment =\
    unterminated comment

msg.unterminated.re.lit =\
    unterminated regular expression literal

msg.invalid.re.flag =\
    invalid flag after regular expression

msg.no.re.input.for =\
    no input for {0}

msg.illegal.character =\
    illegal character

msg.invalid.escape =\
    invalid Unicode escape sequence

msg.bad.namespace =\
    not a valid default namespace statement. \
    Syntax is: default xml namespace = EXPRESSION;

# TokensStream warnings
msg.bad.octal.literal =\
    illegal octal literal digit {0}; interpreting it as a decimal digit

msg.reserved.keyword =\
    illegal usage of future reserved keyword {0}; interpreting it as ordinary identifier

# LiveConnect errors
msg.java.internal.field.type =\
    Internal error: type conversion of {0} to assign to {1} on {2} failed.

msg.java.conversion.implicit_method =\
    Can''t find converter method "{0}" on class {1}.

msg.java.method.assign =\
    Java method "{0}" cannot be assigned to.

msg.java.internal.private =\
    \uB0B4\uBD80 \uC624\uB958: private/protected \uD544\uB4DC "{0}" \uC5D0 \uC811\uADFC\uC744 \uC2DC\uB3C4\uD558\uC600\uC2B5\uB2C8\uB2E4.

msg.java.no_such_method =\
    \uBA54\uC11C\uB4DC {0} \uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.

msg.script.is.not.constructor =\
    Script objects are not constructors.

msg.nonjava.method =\
    Java method "{0}" was invoked with {1} as "this" value that can not be converted to Java type {2}.

msg.java.member.not.found =\
    Java class "{0}" has no public instance field or method named "{1}".

msg.java.array.index.out.of.bounds =\
    Array index {0} is out of bounds [0..{1}].

msg.java.array.member.not.found =\
    Java arrays have no public instance fields or methods named "{0}".

msg.pkg.int =\
    Java package names may not be numbers.

msg.access.prohibited =\
    Access to Java class "{0}" is prohibited.

# ImporterTopLevel
msg.ambig.import =\
    Ambiguous import: "{0}" and and "{1}".

msg.not.pkg =\
    Function importPackage must be called with a package; had "{0}" instead.

msg.not.class =\
    Function importClass must be called with a class; had "{0}" instead.

msg.not.class.not.pkg =\
    "{0}" is neither a class nor a package.

msg.prop.defined =\
    Cannot import "{0}" since a property by that name is already defined.

#JavaAdapter
msg.adapter.zero.args =\
    JavaAdapter requires at least one argument.

msg.not.java.class.arg = \
	Argument {0} is not Java class: {1}.

#JavaAdapter
msg.only.one.super = \
	Only one class may be extended by a JavaAdapter. Had {0} and {1}.


# Arrays
msg.arraylength.bad =\
    Inappropriate array length.

# Arrays
msg.arraylength.too.big =\
    Array length {0} exceeds supported capacity limit.

msg.empty.array.reduce =\
    Reduce of empty array with no initial value

# URI
msg.bad.uri =\
    Malformed URI sequence.

# Number
msg.bad.precision =\
    Precision {0} out of range.

# NativeGenerator
msg.send.newborn =\
  Attempt to send value to newborn generator

msg.already.exec.gen =\
    Already executing generator
    
msg.StopIteration.invalid =\
    StopIteration may not be changed to an arbitrary object.

# Interpreter
msg.yield.closing =\
	Yield from closing generator
